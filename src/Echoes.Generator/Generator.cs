using Echoes.Common;
using Microsoft.CodeAnalysis;
using System;
using System.IO;
using System.Linq;
using System.Text;

namespace Echoes.Generator;

[Generator]
public class Generator : IIncrementalGenerator
{
    private record InvariantLanguageFile
    {
        public string ProjectRelativeTomlFilePath { get; }
        public string GeneratorNamespace { get; }
        public string GeneratorClassName { get; }
        public TomlTranslationParser.TranslationGroup RootGroup { get; }

        public InvariantLanguageFile
        (
            string projectRelativeTomlFilePath,
            string generatorNamespace,
            string generatorClassName,
            TomlTranslationParser.TranslationGroup rootGroup
        )
        {
            ProjectRelativeTomlFilePath = projectRelativeTomlFilePath;
            GeneratorNamespace = generatorNamespace;
            GeneratorClassName = generatorClassName;
            RootGroup = rootGroup;
        }
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<string> projectDirProvider = context.AnalyzerConfigOptionsProvider
           .Select((provider, cancellationToken) =>
           {
               // Try to get the value from MSBuild properties.
               provider.GlobalOptions.TryGetValue("build_property.projectdir", out var projectDir);
               return projectDir ?? string.Empty;
           });

        IncrementalValuesProvider<AdditionalText> translationFiles = context.AdditionalTextsProvider.Where(IsFileRelevant);

        var combinedProvider = translationFiles.Combine(projectDirProvider);

        IncrementalValuesProvider<(string fileName, string content)> fileContents = combinedProvider.Select((source, cancellationToken) =>
        {
            (AdditionalText text, string projectDir) = source;

            var fileName = Path.GetFileNameWithoutExtension(text.Path);
            var content = GenerateKeysFileText(text, projectDir);

            return (fileName, content);
        });

        context.RegisterSourceOutput(fileContents, static (spc, data) =>
        {
            var (fileName, sourceCode) = data;
            spc.AddSource($"{fileName}.g.cs", sourceCode);
        });
    }

    private static bool IsFileRelevant(AdditionalText? additionalFile)
    {
        if (additionalFile == null)
            return false;

        if (!additionalFile.Path.EndsWith(".toml"))
            return false;

        var text = additionalFile.GetText();

        if (text == null)
            return false;

        var stringText = text.ToString();

        return stringText.Contains($"[{TomlTranslationParser.ConfigSectionName}]");
    }

    private static InvariantLanguageFile? ParseTomlFiles(AdditionalText translationFile, string projectDir)
    {
        var text = translationFile.GetText()?.ToString() ?? string.Empty;

        var config = TomlTranslationParser.ParseConfig(text);
        if (config == null)
            return null;

        // Build the nested structure
        var rootGroup = TomlTranslationParser.BuildTranslationStructure(text);

        var trimmedSourceFile = translationFile.Path.StartsWith(projectDir)
            ? translationFile.Path.Substring(projectDir.Length)
            : translationFile.Path;

        return new InvariantLanguageFile(
            trimmedSourceFile,
            config.GeneratedNamespace,
            config.GeneratedClassName,
            rootGroup
        );
    }

    private static string GenerateKeysFileText(AdditionalText translationFile, string projectDir)
    {
        var file = ParseTomlFiles(translationFile, projectDir);

        if (file == null)
            throw new Exception("Failed to parse translation file");

        var sb = new StringBuilder();

        sb.AppendLine($"using Echoes;");
        sb.AppendLine($"using System;");
        sb.AppendLine($"using System.Reflection;");
        sb.AppendLine($"");
        sb.AppendLine($"namespace {file.GeneratorNamespace};");
        sb.AppendLine("");
        sb.AppendLine($"// {file.ProjectRelativeTomlFilePath}");
        sb.AppendLine($"// <auto-generated/>");
        sb.AppendLine($"public static class {file.GeneratorClassName}");
        sb.AppendLine("{");

        sb.AppendLine($"\tprivate static readonly string _file = @\"{file.ProjectRelativeTomlFilePath}\";");
        sb.AppendLine($"\tprivate static readonly Assembly _assembly = typeof({file.GeneratorClassName}).Assembly;");

        GenerateGroupContent(sb, file.RootGroup, 1);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateGroupContent(StringBuilder sb, TomlTranslationParser.TranslationGroup group, int indentLevel)
    {
        var indent = new string('\t', indentLevel);

        // Generate entries for this group
        foreach (var entry in group.Entries.Values.OrderBy(e => e.Key))
        {
            sb.AppendLine(
                $"{indent}private static readonly Lazy<TranslationUnit> _{entry.Key} = new Lazy<TranslationUnit>(() => new TranslationUnit(_assembly, _file, \"{entry.FullPath}\"));");
            sb.AppendLine(
                $"{indent}public static TranslationUnit {entry.Key} => _{entry.Key}.Value;");
        }

        // Generate nested classes (sorted for consistent output)
        foreach (var subGroup in group.SubGroups.Values.OrderBy(g => g.Name))
        {
            sb.AppendLine($"{indent}public static class {subGroup.Name}");
            sb.AppendLine($"{indent}{{");

            GenerateGroupContent(sb, subGroup, indentLevel + 1);

            sb.AppendLine($"{indent}}}");
        }
    }
}